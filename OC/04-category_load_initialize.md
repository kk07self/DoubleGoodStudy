# Category_Load_Initialize

#### Category

- **category实现原理**

  - category在编译时，会被编程成结构体struct category_t，里面存储着原类名、对象方法、类方法、属性、协议信息

  - 在程序运行的时候，runtime会将category中的数据，合并到类信息中（类对象-对象方法、属性信息、协议信息，元类对象-类方法中）

  - 分类的执行顺序：后编译的先执行，分类方法优先于原类方法执行

    - 分类的方法在合并到类信息之前，会按照后编译到先编译的顺序将每个分类的方法数组先后取出

    - 在分类方法合并到类信息中时，会将分类中的方法数组插入到类原方法数组前，即现将原方法数组后移，再讲分类方法插入到最前面


- **category与class extension的区别**
  - class extension在编译的时候就已经将数据合并在类信息中了，category先放在了category——t这样的数据结构中，运行时再合并到类信息中
  - category添加的属性不会自动生成setter和getter方法的实现和成员变量，只会声明setget方法，需要通过runtime自己实现set和get方法
  - class extension 主要是为了不将私有的属性暴露在头文件中，自己内部使用



#### load方法加载

- ```+load```方法会在类、分类被加载到内存的时候调用
- 每个类、分类的```+load```在程序运行过程中只加载一次
- ```+load```的调用过程，区别于普通方法以消息发送机制（objec_senMessage）调用，它是直接拿到```+load```的内存地址（从load方法数组中获取）直接调用
- 如果手动调用```+load```方法，就同普通方法调用一样以消息发送机制进行调用
- 调用顺序：
  - 先调用类的```+load```
    - 无关联的类之间按照编译顺序调用（先编译先调用）
    - 调用子类的```+load```之前会先调用父类的```+load```（如果已经被调用，就跳过直接调用子类的）

  - 再调用分类的```+load```


#### Initialieze

- ```+initialize```在类第一次接收到消息的时候进行调用

- ```+initialize```调用机制是使用的消息传递机制```objc_sendMessage()```进行的

- 调用顺序：

  - 先调用父类的```+initialize```再调用子类的（在调用的时候，应用了递归遍历父类来调用初始化方法）

  - 先初始化父类，再初始化子类，每个类只初始化一次（如果某个类没有实现初始化方法，就会用其superclass指针向上找父类的初始化方法进行调用----消息传递机制进行调用）


#### load与initialize的区别

- **1、调用方式**

  - load的调用方式是，找到load方法的内存地址， 直接进行调用

  - initialize的调用方式是，消息发送机制进行调用（objc_sendMessage）

- **2、调用时间**

  - load是在类被加载到内存的时候进行调用

  - initialize是在类第一次接受到消息的时候进行调用

- **3、调用顺序**

  - load的调用顺序是：
    - 先调用类的，在调用分类的load
      - 先编译的类，优先调用load
      - 调用子类的load前会先调用父类的load(底层在调用之前会递归遍历父类进行调用)
    - 再调用分类的load
      - 分类之间，按照编译顺序进行调用，先编译的先调用（底层将load方法按照编译顺序存储在了有序数组中的）
  - initialize的调用顺序是：
    - 先初始化父类的，再初始化子类的
    - 如果子类没有实现初始化方法，通过superclass向上寻找调用父类的