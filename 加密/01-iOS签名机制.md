# iOS签名机制

本章将涵盖的内容有：

加密解密（对称密码（DES、3DES、AES）、公钥密码(RSA)）—>单向散列函数（MD4、MD5，SHA-1、SHA-2、SHA-3）—>数字签名—>证书—>iOS签名机制

关键字：```encrypt(加密)```、```decryt(解密)```、```plaintext(明文)```、```ciphertext(密文)```

#### 对称密码(symmetric Cryptography)

加密、解密使用的是同一个密钥

- **DES(Data Encryption Standard)：**DES是一种将64bit明文加密成64bit密文的对称密码算法，密钥长度是56bit
- **3DES(Triple Data Encryption Algorithm)：**三重数据加密算法，将DES重复3次所得到的一种密码算法，也叫做3重DES，即通过增加DES的密钥长度来避免类似的攻击
- **AES(Advanced Encryption Standard)：**取代DES成为新标准的一种对称密码算法，AES的密钥长度有128、192、256bit三种

由于加密解密使用的是同一密钥，那在密钥配送的过程就会存在被窃取的风险，一旦截取密钥，那加密后的密文就会轻而易举被解密过来。



有以下几种途径解决此问题，但是有些麻烦：

- 事先共享密钥
- 密钥分配中心
- Diffie-Hellman密钥交换



####公钥密码

加密和解密用的是不同的密钥，即加密密钥和解密密钥，也被称为非对称密码（Asymmetric Cryptography）

- 加密密钥，一般是公开的，因此该密钥称为公钥（public key）

- 解密密钥，由消息接收者自己保管的，不能公开，因此也称为私钥（private key）

- 公钥和私钥是一一对应的，是不能单独生成的，一对公钥和密钥统称为密钥对（key pair）

- 由公钥加密的密文，必须使用与该公钥对应的私钥才能解密

- 由私钥加密的密文，必须使用与该私钥对应的公钥才能解密

**密钥配送流程：**

- 消息接受者生成一对公钥、私钥

- 消息接受者将公钥传递给消息发送者

- 消息发送者用接收者的公钥对消息进行加密，然后传递给消息接收者

- 消息接收者通过用之前生成的私钥来对消息进行解密


**RSA**

目前使用最广泛的公钥密码算法是RSA

RSA的名字，由它的3位开发者，即Ron Rivest、Adi Shamir、Leonard Adleman的姓氏首字母组成



**缺点：**由于非对称加密解密，所以加密解密速度比较慢



####混合密码

是将对称密码和公钥密码的优势相结合的方法

- 解决了公钥密码速度慢的问题

- 并通过公钥密码解决了对称密码的密钥配送问题


**混合密码使用流程：**

- 消息接收者随机生成本次通信的临时密钥（加密用的公钥、解密用的私钥）
- 消息接收者将生成的公钥传递给消息发送者
- 消息发送者生成对称密钥，给消息进行加密生成密文，然后用消息接收者给的公钥给自己的密钥进行加密，生成密钥的密文
- 消息发送者将加密后的消息和加密后的密钥一同发给消息接收者
- 消息接收者用自己的公钥将消息发送者的密钥进行解密得到对称加密的密钥，然后用此密钥对消息密文进行解密获取消息内容





####单向散列函数(One-way hash function)

单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值

单向散列函数，又被称为消息摘要函数（message digest function），哈希函数

输出的散列值，也被称为消息摘要（message digest）、指纹（fingerprint）



**特点：**

- 根据任意长度的消息，计算出固定长度的散列值
- 计算速度快，能快速计算出散列值
- 消息不同，散列值也不同
- 具备单向性，即根据散列值无法算出消息



**当前算法有**

- **MD4、MD5**

  产生128bit的散列值，MD就是Message Digest的缩写，目前已经不安全

  Mac终端上默认可以使用md5命令

  MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通数据的错误检查领域

- **SHA-1**

  产生160bit的散列值，目前已经不安全

- **SHA-2**

  SHA-256、SHA-384、SHA-512，散列值长度分别是256bit、384bit、512bit

- **SHA-3**：Secure Hash Algorithm 3

  全新的安全散列算法

**应用**

- 防止数据被篡改：通过散列值对比数据是否被篡改

- 口令加密：通过散列值来验证输入的口令是否正确（同之前的对比）


####数字签名

生成签名：由消息的发送者完成，通过“签名密钥”生成

验证签名：由消息的接收者完成，通过“验证密钥”验证

**使用流程：**

- **低效使用**：这里对消息进行签名效率会低，尤其是消息数据大时

  - 消息发送者使用自己生成的密钥对的私钥将消息进行加密来签名
  - 消息发送者将签名、消息发送给消息接收者
  - 消息接收者在收到消息后，用消息发送者的公钥将签名进行解密
  - 将解密后的消息与之前消息发送者发送过来的消息进行对比，两者一致则验证成功

- **改进**

  - 消息发送者使用单向散列函数对消息生成散列值

  - 消息发送者使用自己的密钥将散列值进行加密签名

  - 消息发送者将消息和签名发送给消息接收者

  - 消息接收者对收到的消息进行散列函数计算生成散列值，用发送者的公钥对签名进行解密得到散列值

  - 拿自己生成的散列值和解密后的散列值，两者一致则验证成功


**作用**

- 确认消息的完整性

- 识别消息是否被篡改

- 防止消息发送人否认

  如果有人篡改了文件内容，则签名验证失败；如果有人篡改了签名，则解密失败，证明内容被篡改


**缺点**

正确使用签名的前提是，验证签名的公钥必须属于真正的发送者，如果遭中间人攻击，公钥进行伪造，会导致数字签名失效

因此，在验证签名之前，首先验证公钥的合法性



#### 证书

全称叫公钥证书（Public-key Certificate，PKC）

里面有姓名、邮箱等个人信息，以及此人的公钥，并由认证机构（Certificate Authority，CA）施加数字签名，CA就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织

**流程**

- 消息接受者生成密钥对，将公钥传给认证机构
- 认证机构用自己的私钥进行数字签名并生成证书（接收者的公钥+认证机构的数字签名）
- 消息发送者从认证机构获取数字签名后的证书，然后用认证机构的公钥验证数字签名，确认接收者的合法性
- 验证过合法性后，用合法的公钥对消息进行加密，然后发给接收者



#### iOS签名机制

保证安装到用户手机上的APP都是经过Apple官方允许的

**流程**

- 生成mac设备的密钥对（用钥匙串的证书助理获取到certSigningRequest文件）
- 从apple.develperment网站申请证书.cer（需要要上传certSigningRequest文件，就是要Apple用其私钥对mac公钥进行数字签名—>.cer证书文件）
- 申请获得.mobileprovision文件（需要将上面的证书连同app id、devices、entitlements等信息一同用Apple私钥再进行加密签名—>.mobileprovision文件）
- 开发者用mac私钥对app进行加密数字签名—>ipa安装包（APP、签名）
- 用户获取安装包，用apple公钥验证.mobileproviesion文件，获取里面的权限、证书、devices等信息，再用Apple公钥验证证书的签名获取mac公钥
- 用户用验证获取到的mac公钥验证app安装包的数字签名，成功安装应用包



如果是从appstore上下载应用：

- Apple后台对app进行签名（用Apple的私钥）
- 用户用设备上的Apple的公钥进行验证签名，验证通过则进行安装